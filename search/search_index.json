{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Hitloop beacon controller", "text": ""}, {"location": "#hitloop-beacon-controller", "title": "Hitloop beacon controller", "text": "<p>The Hitloop Beacon controller is a device that can be used to generate data from a crowd of people to enable them to control AI generated music tracks. The controllers provide:</p> <ul> <li>an iBeacon scanner to approximate the location of the users</li> <li>an accelerometer to detect the movement of the users</li> <li>an RGB LED to provide feedback</li> <li>a vibration motor to provide feedback</li> </ul> <p>The controller sends the data to a server which then processes the data. Clients can retrieve the data from the server and use it to control the music generation or provide feedback to the controllers themselves.</p> <pre><code>graph TD\n    BS[Beacon scanner]\n    IB[iBeacon]\n    BSRV[Beacon server]\n    MG[Music Generation]\n\n    BS --scans--&gt; IB\n    BS --sends data--&gt; BSRV\n    BSRV --receives data--&gt; MG\n    BS --receives feedback--&gt; BSRV</code></pre>"}, {"location": "#documentation-sections", "title": "Documentation Sections", "text": "<ul> <li>Hardware Details</li> <li>API Endpoints</li> <li>Simulation Page</li> </ul>"}, {"location": "#beacon-controller-server", "title": "Beacon Controller server", "text": "<p>The Beacon Controller server is a Python Flask application. It receives data from the iBeacon and the accelerometer and sends it to the music generation service.</p> <p>The server can be polled to get the current state of the controllers. Each controller can also ask the server for instructions to alter its behaviour based on it\u2019s current state and the state of the crowd.</p> <p>This is the documentation for the HitLoop project.</p>"}, {"location": "#table-of-contents", "title": "Table of Contents", "text": "<ul> <li>Hardware</li> <li>API Reference</li> <li>Simulation</li> <li>Firmware Flashing</li> <li>Control Page</li> <li>Device Configuration</li> <li>Firmware Architecture</li> <li>Webserver Architecture</li> </ul> <p><code>./hardware.md</code> - Details about the scanner and beacon controller hardware. <code>./api.md</code> - Comprehensive reference for the server API endpoints. <code>./simulation.md</code> - Guide to using the web-based device simulation. <code>./firmware.md</code> - Instructions for flashing firmware to the hardware. <code>./control.md</code> - Manual for the real-time device control interface. <code>./device_configuration.md</code> - Guide for setting device credentials via WebSerial. <code>./firmware_architecture.md</code> - An overview of the firmware\u2019s design and data flow. <code>./webserver_architecture.md</code> - An overview of the webserver\u2019s structure and database schema.</p>"}, {"location": "#hitloop", "title": "HitLoop", "text": "<p>A system for interactive wearables.</p>"}, {"location": "api/", "title": "API Reference", "text": ""}, {"location": "api/#api-reference", "title": "API Reference", "text": "<p>This document details the API endpoints for the HitLoop server.</p>"}, {"location": "api/#1-post-data", "title": "1. <code>POST /data</code>", "text": "<p>This is the primary endpoint used by scanners to report their findings to the server. It\u2019s designed to be flexible and can accept data from both real hardware and the simulation.</p> <p>Request Body:</p> <p>The request body must be a JSON object.</p> <ul> <li><code>scanner_id</code> or <code>Scanner name</code> (string, required): The unique identifier of the scanner. The server accepts both keys.</li> <li><code>beacons</code> (list or object, optional):</li> <li>For real devices, this should be a <code>list</code> of beacon objects: <code>[{ \"name\": \"Beacon-A\", \"rssi\": -55 }]</code></li> <li>For the simulation, this can be an <code>object</code> where keys are beacon names: <code>{ \"beacon-NW\": { \"RSSI\": -53, \"Beacon name\": \"NW\" } }</code></li> <li><code>movement</code> (object or number, optional):</li> <li>For real devices, this should be an <code>object</code>: <code>{ \"avgAngleXZ\": 12.3, \"avgAngleYZ\": -5.1, \"totalMovement\": 34.8 }</code></li> <li>For the simulation, this can be a single <code>number</code> representing total movement.</li> <li><code>simulated</code> (boolean, optional): If <code>true</code>, the data is not persisted to the database.</li> </ul> <p>Responses:</p> <ul> <li>200 OK: Indicates the data was successfully received. The response body contains commands for the scanner.</li> <li>Response Body:<ul> <li><code>wait_ms</code> (integer): The number of milliseconds the scanner should wait before its next scan.</li> <li><code>led_behavior</code> (object, optional): A new LED behavior configuration, if one is pending for this scanner.</li> <li><code>vibration_behavior</code> (object, optional): A new vibration behavior configuration, if one is pending.</li> </ul> </li> <li>400 Bad Request: Indicates a missing scanner identifier in the payload.</li> </ul>"}, {"location": "api/#2-post-configurescanner_id", "title": "2. <code>POST /configure/&lt;scanner_id&gt;</code>", "text": "<p>Sets a pending LED or vibration behavior configuration for a specific scanner. The configuration is sent to the scanner the next time it sends data to the <code>/data</code> endpoint.</p> <ul> <li><code>scanner_id</code> (string, URL parameter): The ID of the scanner to configure.</li> </ul> <p>Request Body:</p> <p>A JSON object containing the behavior to set.</p> <ul> <li><code>led_behavior</code> (object, optional): The LED behavior configuration.</li> <li><code>type</code> (string): The name of the behavior (e.g., \u201cSolid\u201d, \u201cHeartBeat\u201d).</li> <li><code>params</code> (object): A key-value map of parameters for the behavior (e.g., <code>color</code>, <code>pulse_duration</code>).</li> <li><code>vibration_behavior</code> (object, optional): The vibration behavior configuration.</li> </ul> <p>Responses:</p> <ul> <li>200 OK: The configuration has been successfully stored on the server.</li> <li>400 Bad Request: The request body did not contain any valid behavior configuration.</li> </ul>"}, {"location": "api/#3-get-devices", "title": "3. <code>GET /devices</code>", "text": "<p>Returns a unified JSON object of all active devices. This endpoint is designed for live-view pages like the index.</p> <p>It works by: 1. Fetching all recently active real devices from the database. 2. Merging this list with the in-memory data, which includes all simulated devices. 3. If a device exists in both, the in-memory data takes precedence, ensuring the view is always current.</p> <p>Responses:</p> <ul> <li>200 OK: A JSON object where each key is a <code>scanner_id</code>. The value contains the latest known data for that scanner.</li> </ul>"}, {"location": "api/#4-get-scanners", "title": "4. <code>GET /scanners</code>", "text": "<p>Returns a JSON object containing the most recent data for all real scanners that have been active within the last 5 minutes. This endpoint only queries the database and will not include simulated devices. It is used by the Control page.</p> <p>Responses:</p> <ul> <li>200 OK:</li> <li>Response Body: A JSON object where each key is a <code>scanner_id</code>. The value contains the latest movement data, a list of observed beacons, and the timestamp from the database.</li> </ul>"}, {"location": "api/#5-get-reset_devices", "title": "5. <code>GET /reset_devices</code>", "text": "<p>Clears all in-memory scanner data and pending device configurations on the server. Note: This does not clear the historical data from the database.</p> <p>Responses:</p> <ul> <li>200 OK: A success message.</li> </ul>"}, {"location": "api/#6-html-page-routes", "title": "6. HTML Page Routes", "text": "<p>These routes serve the user-facing web pages.</p> <ul> <li><code>GET /</code>: Serves the main <code>index.html</code> dashboard, which provides a simple table view of live device data.</li> <li><code>GET /control</code>: Serves the main <code>control.html</code> page, which provides the real-time grid view of active scanners and the controls for configuring them.</li> <li><code>GET /simulation</code>: Serves the <code>simulation.html</code> page for testing the system with simulated scanner data.</li> <li><code>GET /configure_device</code>: Serves the <code>configure_device.html</code> page, which allows setting initial firmware credentials via WebSerial. </li> </ul>"}, {"location": "control/", "title": "Control Page Manual", "text": ""}, {"location": "control/#control-page-manual", "title": "Control Page Manual", "text": "<p>This guide explains how to use the web-based Control Page to monitor and configure the ESP32 scanners in real-time.</p>"}, {"location": "control/#overview", "title": "Overview", "text": "<p>The Control Page provides a centralized interface for interacting with all active scanner devices. It is divided into two main sections:</p> <ol> <li>Scanner Grid (Left): A visual representation of all scanners that have connected to the server in the last 5 minutes.</li> <li>Control Panels (Right): A set of dynamic controls for configuring the LED and vibration behaviors of the selected scanners.</li> </ol>"}, {"location": "control/#1-monitoring-scanners", "title": "1. Monitoring Scanners", "text": "<p>The scanner grid displays a box for each active scanner. Each box shows:</p> <ul> <li>Scanner Name: The unique identifier for the device (e.g., <code>Scanner-84:CB:84</code>).</li> <li>Movement Data: Real-time data from the onboard accelerometer, including angles and total movement since the last update.</li> <li>Last Seen Timestamp: The local time of the last message received from the scanner.</li> </ul> <p>The grid automatically refreshes every 5 seconds to show the latest data and include any new scanners that have come online.</p>"}, {"location": "control/#2-selecting-scanners", "title": "2. Selecting Scanners", "text": "<p>To configure a device, you must first select it.</p> <ul> <li> <p>Single Selection:</p> <ol> <li>Click and drag to draw a selection box around the scanner you want to select.</li> <li>A selected scanner will be highlighted with a green border.</li> </ol> <p>Multiple Selection: 1.  Hold down the <code>Shift</code> key. 2.  While holding <code>Shift</code>, click and drag a selection box. You can repeat this to add multiple, non-adjacent scanners to your selection. Any scanner that falls within the selection rectangle will be added to the current group of selected scanners.</p> </li> </ul> Control panel"}, {"location": "control/#3-configuring-behaviors", "title": "3. Configuring Behaviors", "text": "<p>Once you have one or more scanners selected, you can use the control panels on the right to send them commands.</p> <p>The controls are separated into LED Controls and Vibration Controls.</p>"}, {"location": "control/#applying-a-behavior", "title": "Applying a Behavior", "text": "<ol> <li>Choose a Behavior: Find the form corresponding to the behavior you want to set (e.g., <code>HeartBeat</code> for LEDs or <code>Burst</code> for vibrations).</li> <li>Adjust Parameters:<ul> <li>For behaviors with a color parameter, click the color swatch to open a color picker.</li> <li>For behaviors with numeric parameters (like <code>intensity</code>, <code>frequency</code>, or <code>period</code>), use the sliders to adjust the values. The current value is displayed next to the slider.</li> </ul> </li> <li>Apply: Click the \u201cApply\u201d button within that behavior\u2019s form.</li> </ol> <p>The configuration will be sent to all currently selected scanners. After a successful command, the selection is automatically cleared to prevent accidental re-configuration.</p> <p>Example: To make two scanners pulse with a red light, you would: 1.  Hold <code>Shift</code> and drag a box to select both scanners. 2.  Go to the \u201cLED Controls\u201d panel. 3.  Find the \u201cHeartBeat\u201d form. 4.  Set the color to red (<code>#FF0000</code>). 5.  Adjust the <code>period</code> slider to your desired interval. 6.  Click the \u201cApply\u201d button in the \u201cHeartBeat\u201d form. </p>"}, {"location": "device_configuration/", "title": "Device Configuration Page", "text": ""}, {"location": "device_configuration/#device-configuration-page", "title": "Device Configuration Page", "text": "<p>This guide explains how to use the \u201cConfigure Device\u201d page to set the initial firmware parameters for a scanner using your web browser\u2019s WebSerial capability.</p> Configure Device"}, {"location": "device_configuration/#overview", "title": "Overview", "text": "<p>The Device Configuration page provides a direct interface to a connected scanner\u2019s firmware. It allows you to set essential network settings so the device can connect to your local Wi-Fi and communicate with the central server. This method bypasses the need for hard-coding credentials into the firmware source code.</p> <p>Prerequisites: *   A physical scanner device connected to your computer via USB. *   A modern web browser that supports WebSerial (e.g., Google Chrome, Microsoft Edge, Opera).</p>"}, {"location": "device_configuration/#step-by-step-guide", "title": "Step-by-Step Guide", "text": ""}, {"location": "device_configuration/#1-connect-to-the-device", "title": "1. Connect to the Device", "text": "<p>Before you can send any commands, you must establish a serial connection.</p> <ol> <li> <p>Click \u201cConnect\u201d: On the web page, click the \u201cConnect\u201d button. Your browser will open a pop-up window asking you to select a serial port. Choose the port that corresponds to your ESP32 device (e.g., <code>COM3</code> on Windows, <code>/dev/ttyUSB0</code> on Linux).</p> </li> <li> <p>Put the Device into Configuration Mode: To ensure the device is listening for a serial configuration, press  the \u201cBOOT\u201d button on the XIAO ESP32-C3 board.</p> </li> <li> <p>Verify Connection: Once connected, the button will change to \u201cDisconnect,\u201d and the other UI elements will become active. You should see a \u201cSerial port connected\u201d message in the black serial output terminal at the bottom of the page.</p> </li> </ol>"}, {"location": "device_configuration/#2-configure-settings", "title": "2. Configure Settings", "text": "<p>You have two main options when configuring a device:</p>"}, {"location": "device_configuration/#a-set-network-configuration", "title": "A) Set Network Configuration", "text": "<p>This is the standard operation. Fill in the following fields:</p> <ul> <li>SSID: The name of the Wi-Fi network you want the device to connect to.</li> <li>Password: The password for that Wi-Fi network.</li> <li>Server URL: The full URL that the scanner will send its data to. This must include the protocol, IP address or hostname, port, and endpoint. For example: <code>http://192.168.1.100:5000/data</code>.</li> </ul> <p>Once you have entered the details, click \u201cSend Configuration\u201d.</p>"}, {"location": "device_configuration/#b-erase-configuration", "title": "B) Erase Configuration", "text": "<p>If you want to completely wipe all saved settings from the device\u2019s persistent memory, check the \u201cErase configuration\u201d checkbox.</p> <p>When this box is checked, the network fields will be disabled. Click \u201cSend Configuration\u201d to send the erase command. The device will clear its settings and restart.</p>"}, {"location": "device_configuration/#3-monitor-the-output", "title": "3. Monitor the Output", "text": "<p>The black terminal at the bottom of the page displays all serial communication between your browser and the device. This is extremely useful for debugging. You can see the commands you send and the confirmation messages or error logs that the device prints back. </p>"}, {"location": "firmware/", "title": "Flashing the Firmware", "text": ""}, {"location": "firmware/#flashing-the-firmware", "title": "Flashing the Firmware", "text": "<p>This guide provides instructions for flashing the pre-compiled firmware binaries onto the ESP32-C3 scanner and beacon controller hardware.</p>"}, {"location": "firmware/#prerequisites", "title": "Prerequisites", "text": "<p>Before you begin, ensure you have the following tools installed on your system:</p> <ol> <li> <p>ESPTool: This is the official command-line utility for communicating with the ESP32 ROM bootloader. It is a Python-based tool. If you have Python installed, you can install it via pip:     </p><pre><code>pip install esptool\n</code></pre> </li> <li> <p>Serial Port Driver: Ensure you have the necessary USB-to-UART bridge driver installed for your hardware. For the XIAO ESP32-C3, you may need the CH340 driver, depending on your operating system.</p> </li> </ol>"}, {"location": "firmware/#flashing-instructions", "title": "Flashing Instructions", "text": "<p>The process involves using a script to upload the four necessary binary files (<code>bootloader</code>, <code>partitions</code>, <code>boot_app0</code>, and the main application) to the ESP32-C3 at specific memory addresses.</p>"}, {"location": "firmware/#1-identify-the-serial-port", "title": "1. Identify the Serial Port", "text": "<p>First, connect the ESP32-C3 device to your computer via USB. You must identify the serial port it has been assigned.</p> <ul> <li> <p>Windows: Open the Device Manager. Look under the \u201cPorts (COM &amp; LPT)\u201d section. Your device will likely appear as <code>COM3</code>, <code>COM4</code>, etc.</p> </li> <li> <p>Linux: Open a terminal and run the <code>dmesg | grep tty</code> command after plugging in the device. It will typically appear as <code>/dev/ttyUSB0</code> or <code>/dev/ttyACM0</code>.</p> </li> <li> <p>macOS: Open a terminal and run <code>ls /dev/tty.*</code>. It will likely be listed as <code>/dev/tty.usbserial-XXXXXXXX</code>.</p> </li> </ul>"}, {"location": "firmware/#2-run-the-upload-script", "title": "2. Run the Upload Script", "text": "<p>Navigate to the correct <code>build</code> directory for the firmware you wish to upload (<code>firmware/Scanner/build/...</code> or <code>firmware/hardware_test/build/...</code>).</p> <ul> <li> <p>Windows (Command Prompt or PowerShell):</p> <p>Use the <code>upload.bat</code> script, passing the COM port you identified as an argument.</p> <pre><code># Example for COM3\n./upload.bat COM3\n</code></pre> </li> <li> <p>Linux / macOS (Bash/Zsh):</p> <p>Use the <code>upload.sh</code> script. You may need to make it executable first (<code>chmod +x upload.sh</code>).</p> <pre><code># Example for /dev/ttyUSB0\n./upload.sh /dev/ttyUSB0\n</code></pre> </li> </ul>"}, {"location": "firmware/#3-verification", "title": "3. Verification", "text": "<p>Once the script starts, <code>esptool.py</code> will connect to the device and begin writing the binaries. If successful, you will see output similar to this, followed by the device rebooting:</p> <pre><code>esptool.py v4.5.1\nSerial port /dev/ttyUSB0\nConnecting...\nChip is ESP32-C3 (revision v0.3)\n...\nWriting at 0x00010000... (100 %)\nWrote 1572016 bytes at 0x00010000 in 16.7s...\n...\nHard resetting via RTS pin...\n</code></pre> <p>The device is now flashed with the new firmware. You can open a serial monitor at baud rate <code>115200</code> to view its output. </p>"}, {"location": "firmware_architecture/", "title": "Firmware Architecture", "text": ""}, {"location": "firmware_architecture/#firmware-architecture", "title": "Firmware Architecture", "text": "<p>This document provides a high-level overview of the firmware architecture for the HitLoop Scanner device.</p>"}, {"location": "firmware_architecture/#core-design-philosophy", "title": "Core Design Philosophy", "text": "<p>The firmware is designed around two core principles:</p> <ol> <li>Modularity: Each major piece of functionality (e.g., managing Wi-Fi, handling BLE scans, controlling LEDs) is encapsulated in its own \u201cManager\u201d class.</li> <li>Decoupling: Instead of Managers calling each other directly, they communicate using an event-driven system. A central <code>EventManager</code> is used to broadcast events, and managers subscribe to the events they care about. This reduces dependencies and makes the system easier to modify and test.</li> </ol> <p>All managers inherit from a base <code>Process</code> class, which ensures they have a common <code>setup()</code> and <code>update()</code> interface that is called by the main <code>Scanner.ino</code> sketch.</p>"}, {"location": "firmware_architecture/#system-components-and-data-flow", "title": "System Components and Data Flow", "text": "<p>The diagram below illustrates the primary components of the system and how they interact. The <code>EventManager</code> is the central hub through which all communication flows.</p> <pre><code>graph TD\n    subgraph \"Main Loop (Scanner.ino)\"\n        direction LR\n        loop(Loop) -.-&gt; BleManager\n        loop -.-&gt; WifiManager\n        loop -.-&gt; LedManager\n        loop -.-&gt; VibrationManager\n    end\n\n    subgraph \"Hardware/Logic Managers (Processes)\"\n        BleManager\n        DataManager\n        HTTPManager\n        BehaviorManager\n        WifiManager\n    end\n\n    subgraph \"Actuator Managers\"\n        LedManager\n        VibrationManager\n    end\n\n    subgraph \"Event System\"\n        EventManager((EventManager))\n    end\n\n    BleManager -- Publishes --&gt; ScanCompleteEvent\n    ScanCompleteEvent -- Notifies --&gt; EventManager\n    EventManager -- Subscribed --&gt; DataManager\n\n    DataManager -- Publishes --&gt; DataReadyForHttpEvent\n    DataReadyForHttpEvent -- Notifies --&gt; EventManager\n    EventManager -- Subscribed --&gt; HTTPManager\n\n    HTTPManager -- Publishes --&gt; HttpResponseEvent\n    HttpResponseEvent -- Notifies --&gt; EventManager\n    EventManager -- Subscribed --&gt; BehaviorManager\n\n    HTTPManager -- Publishes --&gt; ServerDisconnectedEvent\n    ServerDisconnectedEvent -- Notifies --&gt; EventManager\n    EventManager -- Subscribed --&gt; BehaviorManager\n\n    WifiManager -- Publishes --&gt; WifiConnectedEvent\n    WifiConnectedEvent -- Notifies --&gt; EventManager\n    EventManager -- Subscribed --&gt; BehaviorManager\n\n    BehaviorManager -- Controls --&gt; LedManager\n    BehaviorManager -- Controls --&gt; VibrationManager\n\n    style loop fill:#f9f,stroke:#333,stroke-width:2px\n    style EventManager fill:#cff,stroke:#333,stroke-width:2px</code></pre>"}, {"location": "firmware_architecture/#data-flow-example-a-full-cycle", "title": "Data Flow Example: A Full Cycle", "text": "<ol> <li><code>BleManager</code>\u2019s timer fires, and it initiates a BLE scan.</li> <li>When the scan completes, <code>BleManager</code> publishes a <code>ScanCompleteEvent</code> containing the results.</li> <li><code>DataManager</code>, which is subscribed to this event, receives it. It processes the raw scan data, combines it with IMU data, and formats it into a JSON payload.</li> <li><code>DataManager</code> then publishes a <code>DataReadyForHttpEvent</code> containing the JSON payload.</li> <li><code>HTTPManager</code> receives this event, opens a connection to the server, and POSTs the data.</li> <li>When the server responds, <code>HTTPManager</code> publishes an <code>HttpResponseEvent</code> with the server\u2019s payload (or a <code>ServerDisconnectedEvent</code> on failure).</li> <li><code>BehaviorManager</code> receives the response event. It parses the payload for any behavior commands (<code>led_behavior</code>, <code>vibration_behavior</code>) or synchronization data (<code>wait_ms</code>).</li> <li>If there are behavior commands, <code>BehaviorManager</code> tells the appropriate manager (<code>LedManager</code> or <code>VibrationManager</code>) which behavior to use from its pool.</li> <li>The <code>LedManager</code> or <code>VibrationManager</code> then runs the <code>update()</code> loop for that behavior on its own, independent of the main loop, ensuring smooth animations.</li> </ol>"}, {"location": "firmware_architecture/#the-behavior-pattern", "title": "The Behavior Pattern", "text": "<p>The firmware uses a \u201cBehavior\u201d pattern to define how the LEDs and vibration motor act. This makes it easy to add new animations or effects.</p> <ul> <li>Base Class: A base class (<code>LedBehavior</code> or <code>VibrationBehavior</code>) defines a common interface with <code>setup()</code>, <code>update()</code>, and <code>updateParams()</code> methods.</li> <li>Concrete Classes: Specific effects like <code>SolidBehavior</code>, <code>HeartBeatBehavior</code>, or <code>BurstVibrationBehavior</code> inherit from the base class and implement the logic for that effect.</li> <li>BehaviorManager: This manager holds a \u201cpool\u201d of all available behavior objects. When it receives a command from the server, it looks up the requested behavior in its pool, updates its parameters (e.g., color, frequency), and tells the relevant <code>LedManager</code> or <code>VibrationManager</code> to use it.</li> <li>Actuator Managers: The <code>LedManager</code> and <code>VibrationManager</code> are simple. They only hold a pointer to the current active behavior and are responsible for calling its <code>update()</code> method. The <code>LedManager</code> uses a <code>Ticker</code> to do this at a fixed interval, ensuring animations are smooth.</li> </ul>"}, {"location": "firmware_architecture/#led-behavior-class-diagram", "title": "LED Behavior Class Diagram", "text": "<pre><code>classDiagram\n    direction LR\n    class LedBehavior {\n        &lt;&lt;Interface&gt;&gt;\n        +type: const char*\n        +setup(pixels) void\n        +update() void\n        +updateParams(params) void\n    }\n\n    class LedsOffBehavior {\n    }\n    class SolidBehavior {\n        +color: uint32_t\n    }\n    class BreathingBehavior {\n        +color: uint32_t\n    }\n    class HeartBeatBehavior {\n        +color: uint32_t\n        +pulse_duration: ulong\n        +pulse_interval: ulong\n        +setParams()\n    }\n    class CycleBehavior {\n        +color: uint32_t\n        +delay: int\n    }\n\n    LedBehavior &lt;|-- LedsOffBehavior\n    LedBehavior &lt;|-- SolidBehavior\n    LedBehavior &lt;|-- BreathingBehavior\n    LedBehavior &lt;|-- HeartBeatBehavior\n    LedBehavior &lt;|-- CycleBehavior</code></pre>"}, {"location": "hardware/", "title": "Hardware", "text": ""}, {"location": "hardware/#hardware", "title": "Hardware", "text": ""}, {"location": "hardware/#beacon-controller", "title": "Beacon Controller", "text": "<p>The controller is based on an ESP32 microcontroller.</p> <p>Bill of materials:</p> <ul> <li>1x XIAO ESP32 microcontroller</li> <li>6x WS2812 RGB LEDs</li> <li>1x LIS2DH12 accelerometer</li> <li>MOSFET based motor driver</li> <li>1x 18650 battery holder</li> <li>1x TP4056 charger module</li> </ul> Schematic pcb_bottom PCB top PCB Bottom"}, {"location": "hardware/#pins", "title": "Pins", "text": "XIAO PIN Function D0 Motor driver D1 WS2812b Data In <p>The LIS2DH12 is connected to the XIAO via I2C.</p>"}, {"location": "hardware/#ibeacon", "title": "iBeacon", "text": "<p>The iBeacon is based on an ESP32 microcontroller. </p>"}, {"location": "simulation/", "title": "Simulation", "text": ""}, {"location": "simulation/#simulation-page-simulation", "title": "Simulation Page (<code>/simulation</code>)", "text": "<p>The server also provides an interactive p5.js simulation to generate test data.</p>"}, {"location": "simulation/#get-simulation", "title": "<code>GET /simulation</code>", "text": "<p>Serves an HTML page with a p5.js canvas that simulates multiple scanners and beacons.</p> Simulation screenshot <p>Page Features:</p> <ul> <li>Visualization:</li> <li>Beacons are displayed as red circles in fixed positions (NW, NE, SW, SE corners).</li> <li>Scanners are displayed as blue squares that move randomly and bounce off canvas edges.</li> <li>Live RSSI values from each scanner to each beacon are displayed as text next to the scanner.</li> <li>Semi-transparent circles are drawn around each beacon, with radii representing the distance to each scanner.</li> <li>Data Generation: Each simulated scanner periodically calculates its distance to all beacons, converts this to a simulated RSSI value, and tracks its own movement. This data is then POSTed to the <code>/data</code> endpoint.</li> <li>Interactivity:</li> <li>Click-to-Move: Clicking on the canvas moves the first scanner (<code>Scanner-A</code>) to the mouse position.</li> </ul> <p>UI Controls Panel:</p> <p>A panel next to (or above) the canvas provides sliders to dynamically control simulation parameters:</p> <ul> <li>Number of Scanners:</li> <li>Range: 1 to 50 (configurable).</li> <li>Adjusting this slider updates the number of simulated scanners.</li> <li>When the value is changed (slider released), it triggers a call to the <code>/reset_devices</code> API endpoint to clear server-side data before repopulating with the new number of scanners.</li> <li>Scanner Max Speed:</li> <li>Controls the maximum speed at which scanners can move.</li> <li>Updates existing scanners in real-time.</li> <li>Velocity Change Magnitude:</li> <li>Controls how erratically the scanners change their direction and speed each frame.</li> <li>Updates existing scanners in real-time.</li> </ul> <p>This simulation page is useful for testing the server endpoints and observing the data flow to the main dashboard page (<code>/</code>). </p>"}, {"location": "webserver_architecture/", "title": "Webserver Architecture", "text": ""}, {"location": "webserver_architecture/#webserver-architecture", "title": "Webserver Architecture", "text": "<p>This document provides a high-level overview of the webserver architecture, focusing on the Flask application structure and the database schema.</p>"}, {"location": "webserver_architecture/#flask-application-structure", "title": "Flask Application Structure", "text": "<p>The webserver is a standard Flask application with a modular structure, organized as follows:</p> <ul> <li><code>run.py</code>: The main entry point to start the Flask development server.</li> <li><code>config.py</code>: Contains basic configuration for the application, such as secret keys and database settings.</li> <li><code>app/</code>: This directory contains the core application logic, structured as a Flask blueprint.<ul> <li><code>__init__.py</code>: Initializes the Flask application, configures the database (Flask-SQLAlchemy), and registers the main blueprint.</li> <li><code>routes.py</code>: Defines all the API endpoints and the logic for handling requests and serving HTML pages.</li> <li><code>models.py</code>: Defines the database schema using SQLAlchemy ORM classes.</li> <li><code>static/</code>: Contains all static assets for the frontend, such as CSS, JavaScript, and images.</li> <li><code>templates/</code>: Contains all Jinja2 HTML templates for the web pages (<code>index.html</code>, <code>control.html</code>, etc.).</li> </ul> </li> </ul>"}, {"location": "webserver_architecture/#database-schema-erd", "title": "Database Schema (ERD)", "text": "<p>The application uses a relational database (managed by Flask-SQLAlchemy) to persist historical data from the scanners. The schema is designed to track scanners, the beacons they detect, and their movement over time.</p> <pre><code>erDiagram\n    Scanner {\n        int id PK\n        string name\n    }\n\n    Beacon {\n        int id PK\n        string name\n    }\n\n    RssiValue {\n        int id PK\n        int scanner_id FK\n        int beacon_id FK\n        int rssi\n        datetime timestamp\n    }\n\n    ScannerMovement {\n        int id PK\n        int scanner_id FK\n        float avg_angle_xz\n        float avg_angle_yz\n        float total_movement\n        datetime timestamp\n    }\n\n    Scanner ||--o{ RssiValue : \"has many\"\n    Scanner ||--o{ ScannerMovement : \"has many\"\n    Beacon ||--o{ RssiValue : \"has many\"</code></pre>"}, {"location": "webserver_architecture/#table-model-explanations", "title": "Table / Model Explanations", "text": ""}, {"location": "webserver_architecture/#scanner", "title": "<code>Scanner</code>", "text": "<p>This table represents the physical scanner devices.</p> <ul> <li><code>id</code>: A unique integer primary key.</li> <li><code>name</code>: A unique string identifier for the scanner, typically its MAC address (e.g., <code>\"64:E8:33:84:CB:84\"</code>). This is the main identifier used throughout the system.</li> </ul>"}, {"location": "webserver_architecture/#beacon", "title": "<code>Beacon</code>", "text": "<p>This table represents the BLE beacon devices that the scanners are detecting.</p> <ul> <li><code>id</code>: A unique integer primary key.</li> <li><code>name</code>: A unique string identifier for the beacon (e.g., <code>\"Beacon-A\"</code>).</li> </ul>"}, {"location": "webserver_architecture/#rssivalue", "title": "<code>RssiValue</code>", "text": "<p>This is a junction table that records a single beacon detection by a single scanner at a specific point in time. It is the core data table of the system.</p> <ul> <li><code>id</code>: A unique integer primary key.</li> <li><code>scanner_id</code>: A foreign key linking to the <code>Scanner</code> that made the observation.</li> <li><code>beacon_id</code>: A foreign key linking to the <code>Beacon</code> that was observed.</li> <li><code>rssi</code>: The Received Signal Strength Indicator measured during the observation.</li> <li><code>timestamp</code>: The UTC timestamp automatically recorded when the observation was saved.</li> </ul>"}, {"location": "webserver_architecture/#scannermovement", "title": "<code>ScannerMovement</code>", "text": "<p>This table logs the movement data captured by a scanner\u2019s Inertial Measurement Unit (IMU) during a scan interval.</p> <ul> <li><code>id</code>: A unique integer primary key.</li> <li><code>scanner_id</code>: A foreign key linking to the <code>Scanner</code> that recorded the movement.</li> <li><code>avg_angle_xz</code> / <code>avg_angle_yz</code>: The average angle of the device on two planes during the interval.</li> <li><code>total_movement</code>: A metric representing the total amount of movement during the interval.</li> <li><code>timestamp</code>: The UTC timestamp automatically recorded when the movement data was saved. </li> </ul>"}]}